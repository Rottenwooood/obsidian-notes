`If you stick to Visual Studio, you will never understand why `vim` is called 编辑器之神. If you stick to Windows, you will never know what is [Unix Philosophy](http://en.wikipedia.org/wiki/Unix_philosophy). If you stick to GUI, you can only do what it can; but in CLI, it can do what you want. One of the most important spirits of young people like you is to try new things to bade farewell to the past.

---
## PA0
- [risiv手册](https://github.com/riscv/riscv-isa-manual/releases/download/draft-20210813-7d0006e/riscv-spec.pdf)
- CLI (Command Line Interface)
- https://nju-projectn.github.io/ics-pa-gitbook/ics2022/0.2.html
查看磁盘使用情况
```
df -h
```
关机（需要权限）
```
poweroff
```
进入root
```
su -
```
Checking network state
```
ping mirrors.tuna.tsinghua.edu.cn -c 4
```

### 安装必要的工具


![[Pasted image 20250723162927.png]]
```
bash -c 'echo "deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse" > /etc/apt/sources.list'
```

```
apt-get update
```

```
apt-get install build-essential    # build-essential packages, include binary utilities, gcc, make, and so on
apt-get install man                # on-line reference manual
apt-get install gcc-doc            # on-line reference manual for gcc
apt-get install gdb                # GNU debugger
apt-get install git                # revision control system
apt-get install libreadline-dev    # a library used later
apt-get install libsdl2-dev        # a library used later
apt-get install llvm llvm-dev      # llvm project, which contains libraries used later
apt-get install llvm-11 llvm-11-dev # only for ubuntu20.04
```
### 004
VIM
```
sudo apt-get install vim
```

```
vim test
```
Some games operated with vim
Here are some games to help you master some basic operations in `vim`. Have fun!

- [Vim Adventures](http://vim-adventures.com)
- [Vim Snake](http://www.vimsnake.com)
- [Open Vim Tutorials](http://www.openvim.com/tutorial.html)
- [Vim Genius](http://www.vimgenius.com)

- XO学vim怎么用
- O关于diff文件
- XO关于配置VIM
### 005
- X[man的使用手册](https://nju-projectn.github.io/ics-pa-gitbook/ics2022/man.html)
- O[Linux入门](https://nju-projectn.github.io/ics-pa-gitbook/ics2022/linux.html)

- X在linux上写一个hello world，
	- X写一个makefile编译他
	- X学学怎么用GDB
		- http://www.cprogramming.com/gdb.html
常用的命令：
- 文件管理 - `cd`, `pwd`, `mkdir`, `rmdir`, `ls`, `cp`, `rm`, `mv`, `tar`
- 文件检索 - `cat`, `more`, `less`, `head`, `tail`, `file`, `find`
- 输入输出控制 - 重定向, 管道, `tee`, `xargs`
- 文本处理 - `vim`, `grep`, `awk`, `sed`, `sort`, `wc`, `uniq`, `cut`, `tr`
- 正则表达式
- 系统监控 - `jobs`, `ps`, `top`, `kill`, `free`, `dmesg`, `lsof`
- 上述工具覆盖了程序员绝大部分的需求
    - 可以先从简单的尝试开始, 用得多就记住了, 记不住就`man`
关于Makefile：
```
# 编译器
CC = gcc

# 编译选项
CFLAGS = -Wall -g

# 目标文件
TARGET = helloworld.exe

# 源文件
SOURCES = main.c

# 生成目标
$(TARGET): $(SOURCES)
    $(CC) $(CFLAGS) -o $(TARGET) $(SOURCES)

# 清理生成文件
clean:
    rm -f $(TARGET)

# 伪目标
.PHONY: clean
```
	注意：缩进必须用Tab
	如果编译c++程序，则选择g++
## PA1
- 配置邮箱，id，姓名等
```
git config --global user.email "2535771636@qq.com"
git config --global user.name "C6H4O2"
```
- git clone
```
git clone -b 2025 git@github.com:NJU-ProjectN/ics-pa.git ics2025
```
- 为git添加SSH公钥（如果报错）
```
ls -al ~/.ssh
ssh-keygen -t ed25519 -C "your_email@example.com"
eval "$(ssh-agent -s)"
ssh-add ~/.ssh/id_ed25519
xclip -sel clip < ~/.ssh/id_ed25519.pub
1. 登录 [GitHub](https://github.com)
2. 点击右上角头像 → **Settings**
3. 左侧菜单选择 **SSH and GPG keys** → **New SSH key**
4. 填写：
    - **Title**: 比如 `My Laptop` 或 `Work PC`
    - **Key type**: 选择 `Authentication`
    - **Key**: 粘贴你复制的公钥内容
5. 点击 **Add SSH key**
```
初始化并新建分支
```
git branch -m master
git config --global --add safe.directory /mnt/DCB6F304B6F2DDC8/development/PA/ics2025
bash init.sh nemu
bash init.sh abstract-machine
```
重新加载环境变量
```
source ~/.bashrc
```
在每个PA？的开始执行
```
git checkout -b pa?
```

```
# 切换branch
git checkout master/pa?
git log
git status
```
---

- 编译NEMU
```
cd nemu
make menuconfig
# 跳出蓝色窗口后直接退出
make
```
---
在开始PA1之前
```
git commit --allow-empty -am "before starting pa1"
git checkout master
git merge pa0
git checkout -b pa1
```
--- 

- 在模拟器中游玩马里奥
	- 操作指南：https://github.com/NJU-ProjectN/fceux-am
	- ROM下载 https://box.nju.edu.cn/f/3e56938d9d8140a7bb75/?dl=1
	- 将游戏ROM放置在`nes/rom/`目录下, 并命名为`xxx.nes`, 如`nes/rom/mario.nes`. 然后可通过`mainargs`选择运行的游戏, 如:
```
make ARCH=native run mainargs=mario
```
操作方式 
- U — SELECT
- I — START
- J — A键
- K — B键
- W/S/A/D — UP/DOWN/LEFT/RIGHT
- Q — 退出
---
多线程编译与编译器缓存
```
make -j?
sudo apt-get install ccache
export PATH="/usr/lib/ccache:$PATH"
```
- 通过多线程编译和编译缓存来加速编译的过程
- ccache：compiler cache
---
指令集架构的选择：
- 我选risicv
- ![[Pasted image 20250822200931.png]]
---
### 002 开天辟地
- 几大要素
	- 存储器：存储代码
	- CPU：执行代码
	- 寄存器：暂存数据
	- 指令：用于控制CPU
	- 程序计数器"(Program Counter, PC)
		- x86中, 它有一个特殊的名字, 叫`EIP`(Extended Instruction Pointer).
	- 约定：计算机按照PC顺序依次执行指令
	- 计算机做了什么：
```
while (1) {
  从PC指示的存储器位置取出指令;
  执行指令;
  更新PC;
}
```
- 图灵机
	- ![[Pasted image 20250822202047.png]]
	- 结构上, TRM有存储器, 有PC, 有寄存器, 有加法器
	- 工作方式上, TRM不断地重复以下过程: 从PC指示的存储器位置取出指令, 执行指令, 然后更新PC
- 计算机是状态机
	- 假设有4个8位寄存器，16字节内存，共计164位，则可表示为有2^164 种状态的状态机
- 程序也是状态机
	- 给定一个程序, 把它放到计算机的内存中, 就相当于在状态数量为`N`的状态转移图中指定了一个初始状态, 程序运行的过程就是从这个初始状态开始, 每执行完一条指令, 就会进行一次确定的状态转移. 也就是说, 程序也可以看成一个状态机!
	- 其状态是计算机这个大的状态机的子集
### 003 RTFSC
```
ics2025
├── abstract-machine   # 抽象计算机
├── am-kernels         # 基于抽象计算机开发的应用程序
├── fceux-am           # 红白机模拟器
├── init.sh            # 初始化脚本
├── Makefile           # 用于工程打包提交
├── nemu               # NEMU
└── README.md
```
- NEMU主要由4个模块构成: monitor, CPU, memory, 设备
- ISA的API
	- https://nju-projectn.github.io/ics-pa-gitbook/ics2025/nemu-isa-api.html
```
nemu
├── configs                    # 预先提供的一些配置文件
├── include                    # 存放全局使用的头文件
│   ├── common.h               # 公用的头文件
│   ├── config                 # 配置系统生成的头文件, 用于维护配置选项更新的时间戳
│   ├── cpu
│   │   ├── cpu.h
│   │   ├── decode.h           # 译码相关
│   │   ├── difftest.h
│   │   └── ifetch.h           # 取指相关
│   ├── debug.h                # 一些方便调试用的宏
│   ├── device                 # 设备相关
│   ├── difftest-def.h
│   ├── generated
│   │   └── autoconf.h         # 配置系统生成的头文件, 用于根据配置信息定义相关的宏
│   ├── isa.h                  # ISA相关
│   ├── macro.h                # 一些方便的宏定义
│   ├── memory                 # 访问内存相关
│   └── utils.h
├── Kconfig                    # 配置信息管理的规则
├── Makefile                   # Makefile构建脚本
├── README.md
├── resource                   # 一些辅助资源
├── scripts                    # Makefile构建脚本
│   ├── build.mk
│   ├── config.mk
│   ├── git.mk                 # git版本控制相关
│   └── native.mk
├── src                        # 源文件
│   ├── cpu
│   │   └── cpu-exec.c         # 指令执行的主循环
│   ├── device                 # 设备相关
│   ├── engine
│   │   └── interpreter        # 解释器的实现
│   ├── filelist.mk
│   ├── isa                    # ISA相关的实现
│   │   ├── mips32
│   │   ├── riscv32
│   │   ├── riscv64
│   │   └── x86
│   ├── memory                 # 内存访问的实现
│   ├── monitor
│   │   ├── monitor.c
│   │   └── sdb                # 简易调试器
│   │       ├── expr.c         # 表达式求值的实现
│   │       ├── sdb.c          # 简易调试器的命令处理
│   │       └── watchpoint.c   # 监视点的实现
│   ├── nemu-main.c            # 你知道的...
│   └── utils                  # 一些公共的功能
│       ├── log.c              # 日志文件相关
│       ├── rand.c
│       ├── state.c
│       └── timer.c
└── tools                      # 一些工具
    ├── fixdep                 # 依赖修复, 配合配置系统进行使用
    ├── gen-expr
    ├── kconfig                # 配置系统
    ├── kvm-diff
    ├── qemu-diff
    └── spike-diff
```
- 从nemu-main.c开始看代码吧
NEMU中的配置系统位于`nemu/tools/kconfig`, 它来源于GNU/Linux项目中的kconfig, 我们进行了少量简化. kconfig定义了一套简单的语言, 开发者可以使用这套语言来编写"配置描述文件". 在"配置描述文件"中, 开发者可以描述:

- 配置选项的属性, 包括类型, 默认值等
- 不同配置选项之间的关系
- 配置选项的层次关系
目前我们只需要关心配置系统生成的如下文件:

- `nemu/include/generated/autoconf.h`, 阅读C代码时使用
- `nemu/include/config/auto.conf`, 阅读Makefile时使用

```
$(OBJ_DIR)/%.o: %.c
  @echo + CC $<
  @mkdir -p $(dir $@)
  @$(CC) $(CFLAGS) -c -o $@ $<
  $(call call_fixdep, $(@:.o=.d), $@)
```
- ![[Pasted image 20250822212157.png]]
- ![[Pasted image 20250822212211.png]]
> 将任意 `.c` 文件编译为对应的 `.o` 文件，输出到 `$(OBJ_DIR)` 目录中，同时：
> 
> - 自动创建所需目录
> - 显示编译信息
> - 生成 `.d` 依赖文件，实现头文件变更后自动重新编译

准备第一个客户程序
- 我们需要将客户程序读入到客户计算机中, 这件事是monitor来负责的.
- 首先会调用`init_monitor()`函数(在`nemu/src/monitor/monitor.c`中定义)
```c
void init_monitor(int argc, char *argv[]) {
  /* Perform some global initialization. */

  /* Parse arguments. */
  parse_args(argc, argv);

  /* Set random seed. */
  init_rand();

  /* Open the log file. */
  init_log(log_file);

  /* Initialize memory. */
  init_mem();

  /* Initialize devices. */
  IFDEF(CONFIG_DEVICE, init_device());

  /* Perform ISA dependent initialization. */
  init_isa();

  /* Load the image to memory. This will overwrite the built-in image. */
  long img_size = load_img();

  /* Initialize differential testing. */
  init_difftest(diff_so_file, img_size, difftest_port);

  /* Initialize the simple debugger. */
  init_sdb();

  IFDEF(CONFIG_ITRACE, init_disasm());

  /* Display welcome message. */
  welcome();
}
```
删去welcome()函数实现末尾的两行代码
```c
static void welcome() {
  Log("Trace: %s", MUXDEF(CONFIG_TRACE, ANSI_FMT("ON", ANSI_FG_GREEN), ANSI_FMT("OFF", ANSI_FG_RED)));
  IFDEF(CONFIG_TRACE, Log("If trace is enabled, a log file will be generated "
        "to record the trace. This may lead to a large log file. "
        "If it is not necessary, you can disable it in menuconfig"));
  Log("Build time: %s, %s", __TIME__, __DATE__);
  printf("Welcome to %s-NEMU!\n", ANSI_FMT(str(__GUEST_ISA__), ANSI_FG_YELLOW ANSI_BG_RED));
  printf("For help, type \"help\"\n");
  // Log("Exercise: Please remove me in the source code and compile NEMU again.");
  // assert(0);
}
```

```
make run
```

```
(base) c6h4o2@c6h4o2:~/development/PA/ics2025/nemu$ make run
+ CC src/monitor/monitor.c
+ LD /home/c6h4o2/development/PA/ics2025/nemu/build/riscv32-nemu-interpreter
/home/c6h4o2/development/PA/ics2025/nemu/build/riscv32-nemu-interpreter --log=/home/c6h4o2/development/PA/ics2025/nemu/build/nemu-log.txt  
[src/utils/log.c:30 init_log] Log is written to /home/c6h4o2/development/PA/ics2025/nemu/build/nemu-log.txt
[src/memory/paddr.c:50 init_mem] physical memory area [0x80000000, 0x87ffffff]
[src/monitor/monitor.c:51 load_img] No image is given. Use the default build-in image.
[src/monitor/monitor.c:28 welcome] Trace: ON
[src/monitor/monitor.c:29 welcome] If trace is enabled, a log file will be generated to record the trace. This may lead to a large log file. If it is not necessary, you can disable it in menuconfig
[src/monitor/monitor.c:32 welcome] Build time: 09:41:47, Aug 23 2025
Welcome to riscv32-NEMU!
For help, type "help"
(nemu) c
[src/cpu/cpu-exec.c:120 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x8000000c
[src/cpu/cpu-exec.c:88 statistic] host time spent = 74 us
[src/cpu/cpu-exec.c:89 statistic] total guest instructions = 4
[src/cpu/cpu-exec.c:90 statistic] simulation frequency = 54,054 inst/s
(nemu) c
Program execution has ended. To restart the program, exit NEMU and run again.
(nemu) q
(base) c6h4o2@c6h4o2:~/development/PA/ics2025/nemu$ 
```

TRM的实现已经都蕴含在上述的介绍中了.

- 存储器是个在`nemu/src/memory/paddr.c`中定义的大数组
- PC和通用寄存器都在`nemu/src/isa/$ISA/include/isa-def.h`中的结构体中定义
- 加法器在... 嗯, 这部分框架代码有点复杂, 不过它并不影响我们对TRM的理解, 我们还是在PA2里面再介绍它吧
- TRM的工作方式通过`cpu_exec()`和`exec_once()`体现