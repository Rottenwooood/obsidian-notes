```
ls -a 查看隐藏文件
```



```
$ mkdir temp      # 创建一个目录temp
$ cd temp         # 切换到目录temp
$ touch newfile   # 创建一个空文件newfile
$ mkdir newdir    # 创建一个目录newdir
$ cd newdir       # 切换到目录newdir
$ cp ../newfile . # 将上级目录中的文件newfile复制到当前目录下
$ cp newfile aaa  # 将文件newfile复制为新文件aaa
$ mv aaa bbb      # 将文件aaa重命名为bbb
$ mv bbb ..       # 将文件bbb移动到上级目录
$ cd ..           # 切换到上级目录
$ rm bbb          # 删除文件bbb
$ cd ..           # 切换到上级目录
$ rm -r temp      # 递归删除目录temp
```
##### 统计代码行数

第一个例子是统计一个目录中(包含子目录)中的代码行数. 如果想知道当前目录下究竟有多少行的代码, 就可以在命令行中键入如下命令:

```
find . | grep '\.c$\|\.h$' | xargs wc -l
```
## 统计磁盘使用情况

以下命令统计`/usr/share`目录下各个目录所占用的磁盘空间:
```
du -sc /usr/share/* | sort -nr
```
`du`是磁盘空间分析工具, `du -sc`将目录的大小顺次输出到标准输出, 继而通过管道传送给`sort`. `sort`是数据排序工具, 其中的选项`-n`表示按照数值进行排序, 而`-r`则表示从大到小输出. `sort`可以将这些参数连写在一起.
然而我们发现, `/usr/share`中的目录过多, 无法在一个屏幕内显示. 此时, 我们可以再使用一个命令: `more`或`less`.
```
du -sc /usr/share/* | sort -nr | more
```

此时将会看到输出的前几行结果. `more`工具使用空格翻页, 并可以用`q`键在中途退出. `less`工具则更为强大, 不仅可以向下翻页, 还可以向上翻页, 同样使用`q`键退出. 这里还有一个[关于less的小故事](http://en.wikipedia.org/wiki/Less_\(Unix\)).
## 在Linux下编写Hello World程序
```
apt-get install emacs
vi hello.c
或emacs hello.c
// 编辑操作
gcc hello.c -o hello
```
## 使用重定向

有时我们希望将程序的输出信息保存到文件中, 方便以后查看. 例如你编译了一个程序`myprog`, 你可以使用以下命令对`myprog`进行反汇编, 并将反汇编的结果保存到`output`文件中:

```
objdump -d myprog > output
```

`>`是标准输出重定向符号, 可以将前一命令的输出重定向到文件`output`中. 这样, 你就可以使用文本编辑工具查看`output`了.

但你会发现, 使用了输出重定向之后, 屏幕上就不会显示`myprog`输出的任何信息. 如果你希望输出到文件的同时也输出到屏幕上, 你可以使用`tee`命令:

```
objdump -d myprog | tee output
```

使用输出重定向还能很方便地实现一些常用的功能, 例如

```
> empty                  # 创建一个名为empty的空文件
cat old_file > new_file  # 将文件old_file复制一份, 新文件名为new_file
```

如果`myprog`需要从键盘上读入大量数据(例如一个图的拓扑结构), 当你需要反复对`myprog`进行测试的时候, 你需要多次键入大量相同的数据. 为了避免这种无意义的重复键入, 你可以使用以下命令:

```
./myprog < data
```

`<`是标准输入重定向符号, 可以将前一命令的输入重定向到文件`data`中. 这样, 你只需要将`myprog`读入的数据一次性输入到文件`data`中, `myprog`就会从文件`data`中读入数据, 节省了大量的时间.

下面给出了一个综合使用重定向的例子:

```
time ./myprog < data | tee output
```

这个命令在运行`myprog`的同时, 指定其从文件`data`中读入数据, 并将其输出信息打印到屏幕和文件`output`中. `time`工具记录了这一过程所消耗的时间, 最后你会在屏幕上看到`myprog`运行所需要的时间. 如果你只关心`myprog`的运行时间, 你可以使用以下命令将`myprog`的输出过滤掉:

```
time ./myprog < data > /dev/null
```

`/dev/null`是一个特殊的文件, 任何试图输出到它的信息都会被丢弃, 你能想到这是怎么实现的吗? 总之, 上面的命令将`myprog`的输出过滤掉, 保留了`time`的计时结果, 方便又整洁.
## 使用Makefile管理工程

大规模的工程中通常含有几十甚至成百上千个源文件(Linux内核源码有25000+的源文件), 分别键入命令对它们进行编译是十分低效的. Linux提供了一个高效管理工程文件的工具: GNU Make. 我们首先从一个简单的例子开始, 考虑上文提到的Hello World的例子, 在`hello.c`所在目录下新建一个文件`Makefile`, 输入以下内容并保存:

```
hello:hello.c
    gcc hello.c -o hello    # 注意开头的tab, 而不是空格

.PHONY: clean

clean:
    rm hello    # 注意开头的tab, 而不是空格
```

返回命令行, 键入`make`, 你会发现`make`程序调用了`gcc`进行编译. `Makefile`文件由若干规则组成, 规则的格式一般如下:

```
目标文件名:依赖文件列表
    用于生成目标文件的命令序列   # 注意开头的tab, 而不是空格
```

我们来解释一下上文中的`hello`规则. 这条规则告诉`make`程序, 需要生成的目标文件是`hello`, 它依赖于文件`hello.c`, 通过执行命令`gcc hello.c -o hello`来生成`hello`文件.

如果你连续多次执行`make`, 你会得到"文件已经是最新版本"的提示信息, 这是`make`程序智能管理的功能. 如果目标文件已经存在, 并且它比所有依赖文件都要"新", 用于生成目标的命令就不会被执行. 你能想到`make`程序是如何进行"新"和"旧"的判断的吗?

上面例子中的`clean`规则比较特殊, 它并不是用来生成一个名为`clean`的文件, 而是用于清除编译结果, 并且它不依赖于其它任何文件. `make`程序总是希望通过执行命令来生成目标, 但我们给出的命令`rm hello`并不是用来生成`clean`文件, 因此这样的命令总是会被执行. 你需要键入`make clean`命令来告诉`make`程序执行`clean`规则, 这是因为`make`默认执行在`Makefile`中文本序排在最前面的规则. 但如果很不幸地, 目录下已经存在了一个名为`clean`的文件, 执行`make clean`会得到"文件已经是最新版本"的提示. 解决这个问题的方法是在`Makefile`中加入一行`PHONY: clean`, 用于指示"`clean`是一个伪目标". 这样以后, `make`程序就不会判断目标文件的新旧, 伪目标相应的命令序列总是会被执行.

对于一个规模稍大一点的工程, `Makefile`文件还会使用变量, 函数, 调用Shell命令, 隐含规则等功能. 如果你希望学习如何更好地编写一个`Makefile`, 请到互联网上搜索相关资料.

- wget
- vim